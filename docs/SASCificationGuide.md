This is a general guide for creating a new SASC resource, or for transitioning an existing resource into SASC. When in doubt, check a previous resource for a guide (Bios on `static_pages\Team.jsx`, Agreements and Portfolios are good).

You might also be interested in:

* [The formal definition of SASC as a protocol](SwellAPIStandardConvention.md)
* [The server-side Rails SASC library reference](RailsSASC.md)
* [The client-side Redux resourceLib reference](ReduxSASC.md)

## Table of Contents

<!-- This table of contents can be automatically regenerated by yarn run docs -->

<!-- toc -->

- [Step 1: Create the Server Side Resources](#step-1-create-the-server-side-resources)
  * [Controllers, the Read-Only Basics](#controllers-the-read-only-basics)
    + [Basic Methods: model_scope, index, and show](#basic-methods-model_scope-index-and-show)
  * [The `Resource` Class: Read-Only Basics](#the-resource-class-read-only-basics)
      - [Creating a Basic Resource](#creating-a-basic-resource)
      - [Customizing and Decorating the Resource](#customizing-and-decorating-the-resource)
  * [Create Update Delete: How to Mutate a SASC record](#create-update-delete-how-to-mutate-a-sasc-record)
    + [Standard Controller Mutation: `create`, `update`, and `destroy` actions](#standard-controller-mutation-create-update-and-destroy-actions)
    + [Bonus Round: Custom SASC Controller Actions](#bonus-round-custom-sasc-controller-actions)
    + [Resource Mutation: Making Attributes Settable and Resources Modifiable](#resource-mutation-making-attributes-settable-and-resources-modifiable)
      - [Using `res_creatable`, `res_updatable` and `res_destroyable`](#using-res_creatable-res_updatable-and-res_destroyable)
      - [Customizing the methodable calls](#customizing-the-methodable-calls)
      - [Using `settable_for` to make fields settable](#using-settable_for-to-make-fields-settable)
      - [Resource relationships and setting the target scope](#resource-relationships-and-setting-the-target-scope)
      - [Using #assign to customize how a field is set](#using-%23assign-to-customize-how-a-field-is-set)
- [Step 2: Hook It Up](#step-2-hook-it-up)
    + [Restful Routes](#restful-routes)
    + [Vestigial Views](#vestigial-views)
  * [** INTERSTITIAL BREAK: THIS IS A GOOD TIME TO UPDATE YOUR TESTS! AND GO GET A SNACK. YOU DESERVE IT. **](#-interstitial-break-this-is-a-good-time-to-update-your-tests-and-go-get-a-snack-you-deserve-it-)
- [Step 3: Convert The Client](#step-3-convert-the-client)
  * [Resource Definitions, aka Where the Magic Happens](#resource-definitions-aka-where-the-magic-happens)
  * [Component File Conversion](#component-file-conversion)
    + [Import WithResources and selectors](#import-withresources-and-selectors)
    + [Convert mapStateToProps to mapSelectorsToProps](#convertingmapState)
    + [Write selectors as necessary](#write-selectors-as-necessary)
    + [Set up WithResources](#set-up-withresources)
    + [Alternate approach: `safeConnect`](#alternate-approach-safeconnect)
    + [Saga Conversions using `diligentSelect` and `runResourceProcess`](#saga-conversions-using-diligentselect-and-runresourceprocess)
  * [Step 4: Testing](#step-4-testing)
    + [Server-Side Testing](#server-side-testing)
      - [Required Helper Methods](#required-helper-methods)
      - [Optional Helper Methods](#optional-helper-methods)
      - [Setting the SASC params](#setting-the-sasc-params)
    + [Client-Side Testing](#client-side-testing)
      - [Mocking state with resources using `buildResourceState`](#mocking-state-with-resources-using-buildresourcestate)
    + [Cleanup/Optional](#cleanupoptional)

<!-- tocstop -->

# Step 1: Create the Server Side Resources

The first step to a new SASC resource is to create two things:

* A controller which inherits from the SASCBaseController
* A resource class on the server which inherits from SASC::Resource

This creates the baseline for the resource in the API and will allow it to process requests. 


## Controllers, the Read-Only Basics

Some controllers will also have create/update/destroy methods, which are detailed in the next section. However, this section is only about how to set up the read-only methods for a controller.

### Basic Methods: model_scope, index, and show

To create a new controller, make a new file in `app/controllers/api/` or modify the existing controller file. Most methods will start out inheriting from SASCBaseController, but you can overwrite them as needed. To convert an existing controller to SASC, modify the inherited parent from BaseController to SASCBaseController. A good way to do this is to comment out the existing controller's contents and replace them one by one into the new controller.

```
# app/controllers/api/samples_controller.rb

module Api
  class SamplesController < SASCBaseController
    def model_scope
      # possible implementations include:
      Sample.all
      current_user.samples
      Sample.order(:position)
    end

    # def index
    #  defaults to sasc_index
    #  block index requests by using `raise SASC::Errors::Unauthorized` here
    # end

    # def show
    #  defaults to sasc_show
    #  insert methods or services to run here if needed
    # end
  end
end
```

**You must define model_scope for each SASC controller**. In contrast, `index` and `show` are both inherited methods from the SASCBaseController and are implemented by default if you do not overwrite them.

As a default, `index` calls `sasc_index` which renders all the resources gathered by the inherited `fetch_index_records` method, and `show` calls `sasc_show` which renders a single resource based on the id in `params` using the inherited `fetch_individual_record` method.

You can modify their behavior as needed by changing the scope, overriding the inherited search functions, changing the `show` or `index` method, etc. For example, the Agreements controller has some modifications to the basic controller:

```
# app/controllers/api/agreements_controller.rb

module Api
  class AgreementsController < SASCBaseController
    def model_scope
      Agreement.all_latest_for_date(Time.zone.today)
    end

    def fetch_index_records
      super.sort_by do |agreement|
        Agreement.agreements_display_order.find_index(agreement.key) || 1000
      end
    end
  end
end
```

In the Agreements controller, the scope is limited to the latest Agreements by date, and the index records function is overwritten to sort the agreements by display order. The `index` and `show` methods are not shown here because we are using the inherited methods from the SASCBaseController, not overwriting them.

**Note:** The SASCBaseController also includes a method called `resource_class`, which defaults to `ResourceName` (ex. this samples_controller.rb will have a default resource class of `SampleResource`. It is unlikely that you will need to overwrite this method but it is possible to do so in the same way you would overwrite the index, show etc methods.

## The `Resource` Class: Read-Only Basics

The Resource class for the new SASC resource describes the attributes that will be sent to the client with each API call. **This file should include all attributes that you want to be viewable and/or modifiable.** It replaces both the json view file and the controller params for any controller that had CUD functionality. The contents of this file will become the
```
"attributes": {
   ...
}
```
part of the JSON. However, you should not include the object's ID here because SASC JSON already includes the ID as a separate field.

#### Creating a Basic Resource

```
class SampleResource < SASC::Resource
  res_attribute :name, :string
  res_attribute :description, :string
  res_attribute :effective_date, :string
end
```

These types (:string, :integer etc) are **not** the database types for these fields: they are **the JSON types of content that will be returned by the API request.** This also does NOT have to be a complete list of the attributes on the model - instead, it should only be the attributes actually needed by the client.

#### Customizing and Decorating the Resource

You can customize these resource fields with certain types of functions/blocks. For example, you can pass a block to the `lookup` option to override the default #read method (eg. if the method has a different name in the database, or if it needs additional post-processing before being sent to the client). 

```
class AgreementResource < SASC::Resource
  def decorated_record
    @decorated_record ||= record.decorate
  end
  
  res_attribute :name, :string
  res_attribute :effective_on, :string
  res_attribute :link, :string, lookup: -> (res) { res.record.agreement_link(Time.zone.today) }
end
```

In the Agreements resource, the `:effective_on` attribute (which will be named on the client as `effectiveOn`) is a date in `schema.rb`, but it will be rendered by the API as a string, so it is registered as a `:string` in `AgreementResource`. Agreements also contain a `:text` attribute, but the text is not needed in our client app, so it does not need to be included in the SASC resource.

The method `decorated_record` can be defined at the top of the file. If it is present exactly as it is above, this will decorate the record before it is read by the client using the record's Draper decorator (for example, the AgreementResource here is now decorated by the methods in `agreement_decorator.rb`). At this time we do not support or encourage modifying this method. If you do not need to decorate your records, do not include the decorated_record method. 

## Create Update Delete: How to Mutate a SASC record

Now the fun part: modifying your SASC controller to allow for creating, updating and destroying records. These methods are all OPTIONAL and will be compacted out of the resource during processing, unless they are defined here in the controller.

### Standard Controller Mutation: `create`, `update`, and `destroy` actions

Unlike `show` and `index`, no default implementations are provided for `create`, `update` and `destroy`. However, implementing these routes is easy to start because SASCBaseController already includes default `sasc_create`, `sasc_update` and `sasc_destroy` methods. 

To use a default CUD method in your new SASC controller, simply add a method definition that points to the corresponding SASC CUD method.

```
# controllers/api/samples_controller.rb

def create
   sasc_create
end

def update
   sasc_update
end

def destroy
   sasc_destroy
end
```
In order for this to work, you will need to add supporting code in the resource class file. For more information, see below. **TODO: link this.**

You can also add workers, service calls, and/or custom behaviors after the `sasc_create` method has run by saving the return value of that method as a variable and then acting on it.  Include the necessary workers/services etc as you would in a regular controller. For example, the `recurring_investments_controller.rb` includes before actions, workers, and services around the `sasc_create` method. 

```
module Api
  class RecurringInvestmentsController < SASCBaseController
    before_action :authorize_user
    before_action :ensure_active_account

    def model_scope
      RecurringInvestment.for_user(current_user)
    end

    def create
      resource = sasc_create
      sync_users_with_crm_worker.perform_async(current_user.id, 'recurring_investment')
      user_mailer.confirm_recurring_investment(resource.record).deliver_with_sidekiq
    end
    
    def sync_users_with_crm_worker
      @sync_users_with_crm_worker ||= SyncUsersWithCrmWorker
    end

    def user_mailer
      @user_mailer ||= UserMailer
    end
  end
end
```
All controller params will be moved to the `sample_resource.rb` resource class file. For more information, see below.

### Bonus Round: Custom SASC Controller Actions

In some cases you will need to write a custom controller action, like `close` for accounts. In order to do so, add a custom res_sasc_action call to your controller. The call takes parameters that determine how the custom action will work. The basic structure looks like this:

```ruby
res_sasc_action(
  :announce_everyone,   # the name of your custom action
  :collection,			# what the action operates on (options are :individual and :collection)
  arguments: { excitement: :integer },    # (optional) specify what information the client must send and in what JSON type
  result: { loud_announcements: :array }  # (optional) specify what information will be returned and in what JSON type
) do |arguments|
  announcements = model_scope.map { |rec| announcement_service.shout(rec, arguments[:excitement]) }
  { loud_announcements: announcements }   # block must return a hash corresponding to the result 
end
```
Here's an example from the `RecurringInvestmentsController`:

```
res_sasc_action :calculate_next_dates, :collection, result: { monthly: :object, weekly: :object } do
  next_recurring_investment_dates_service.all_next_recurring_investment_dates
end
```
**Make sure you also add a route for this custom action into `config/routes.rb`.** See below in Step 2: Hook It Up for an example.

In this example, the `all_next_recurring_investment_dates` call returns the following hash, which is mapped onto the result of the `res_sasc_action` custom action: 

`{"monthly"=>{"the_first"=>Mon, 02 Apr 2018, "the_fifteenth"=>Thu, 15 Mar 2018}, "weekly"=>{"monday"=>Mon, 12 Mar 2018, "tuesday"=>Tue, 06 Mar 2018, "wednesday"=>Wed, 07 Mar 2018, "thursday"=>Thu, 08 Mar 2018, "friday"=>Fri, 09 Mar 2018}}`

### Resource Mutation: Making Attributes Settable and Resources Modifiable

Now that you've created CUD methods in the controller, you'll need to make them possible by adding supporting code to the SASC resource class. To do this, you'll need to use a few new methods: creatable, updatable and destroyable. 

#### Using `res_creatable`, `res_updatable` and `res_destroyable`

The simplest way of making a resource modifiable is to add a single line for each action you want to enable into the `sample_resource.rb` file:

```
class SampleResource < SASC::Resource
  res_creatable
  res_updatable
  res_destroyable
end
```
If you don't provide a customizing block for these methods (see below), the default implementation of each method will simply call `save!` or `destroy!` on the record like this:

```
res_creatable do |resource|
  resource.record.save!
end
```
**As a general rule**, we recommend putting any modification that has to happen to the record _before_ the changes are applied to the database into the resource, and any actions or changes that happen _after_ the save/destroy in the controller. The goal is to keep all the record modification actions together inside the `methodable` block so they succeed or fail together. After the record is modified, you can call other systems like mailers or syncs.

#### Customizing the methodable calls
If you need to customize how the record is created/updated/destroyed, you can pass a block to the `res_methodable` call that calls the appropriate save function and does any other necessary work. Your block will be called AFTER all the attributes have been assigned for you by the params.

Here we will compare the old RecurringInvestment Controller, which used the `build_recurring_investment` method to set `next_scheduled_on` during #create and #update, with the new SASC RecurringInvestmentController which now lets the resource set that field.

**OLD:**

```
# controllers/recurring_investment_controller.rb

def create
  @recurring_investment = build_recurring_investment(recurring_investment_params)
  ...
end

def build_recurring_investment(params)
  RecurringInvestment.new(params).tap do |recurring_investment|
    update_next_scheduled_on(recurring_investment)
  end
end

def update_next_scheduled_on(recurring_investment)
  next_scheduled_on = next_recurring_investment_date_calculator.calculate_for(recurring_investment)
  recurring_investment.next_scheduled_on = next_scheduled_on
end

private

def next_recurring_investment_date_calculator
  NextRecurringInvestmentDateCalculator.new
end
```

**NEW:**

In the new SASC controller, we still need to create the `NextRecurringInvestmentDateCalculator` in the controller because we're still following the normal controller service pattern, where services/workers/etc are instantiated using controller methods. In order to use this calculator in the resource file, we tap into `context` and merge the calculator into the contextual params that are passed from the SASCBaseController to every resource. 

**Important:** it is necessary to call the `sasc_create` method inside the controller's def create method (same for update and destroy) or nothing will happen. If you need to act on the resource afterwards, you can save the result of the `sasc_*` method as a local `resource` variable as it is below (or save it as something fun, like `unicorn` or `fuzzy_bacon`). 

```
# controllers/recurring_investment_controller.rb

def create
  resource = sasc_create
  sync_users_with_crm_worker.perform_async(current_user.id, 'recurring_investment')
  user_mailer.confirm_recurring_investment(resource.record).deliver_with_sidekiq
end

def context
  super.merge({next_recurring_investment_date_calculator: next_recurring_investment_date_calculator})
end
    
private

def next_recurring_investment_date_calculator
  NextRecurringInvestmentDateCalculator.new
end
```
Now, we can move the helper methods that were formerly in our old non-SASC controller to the RecurringInvestmentResource and call them during our customized `res_creatable` action.

```
# resources/recurring_investment_resource.rb

class RecurringInvestmentResource < SASC::Resource

  res_creatable do |resource|
    resource.update_next_scheduled_on
    resource.record.save!
  end

  def update_next_scheduled_on
    next_scheduled_on = context[:next_recurring_investment_date_calculator].calculate_for(self.record)
    raise ServiceError.new('unable to calculate next_scheduled_on date') if next_scheduled_on.nil?

    self.record.next_scheduled_on = next_scheduled_on
    self.record.next_notify_on = next_scheduled_on - 3
  end
end
```

#### Using `settable_for` to make fields settable

If you have added create, update and/or destroy actions in the controller, you need to make the resource's attributes settable as well. If SASC receives instructions to create or update from the client, it will check to see which individual attributes are settable **by the client** on either #create, #update or both. In order to indicate that the attribute is settable, you can add `settable_for` option to the target field along with an array of possible actions. 

You do not need to make every attribute settable, only the ones you want the client to be able to change (for example, perhaps a user can change their address from the client interface but not their birthdate or their privilege roles in the application).

```
class RecurringInvestmentResource < SASC::Resource
  res_attribute :next_scheduled_on, :string
  res_attribute :day_of_month, :string, settable_for: [:create, :update]
  res_attribute :day_of_week, :string, settable_for: [:create, :update]
end
```

#### Resource relationships and setting the target scope
SASC also provides a `settable_target_scope` option, which is mainly used to scope the records of an associated model in order to limit which records are available to be set (commonly used to scope associated records to the current user). In fact, **it is required that if you make an association settable on a resource, you must include a settable target scope.** 

For example, the RecurringInvestmentResource can set its own `:bank_link_id` association field, but we want to limit the BankLinks it can choose from to those that are owned by the current user. To accomplis this, we passed a scoping block to the `res_has_one_relationship` attribute of RecurringInvestmentResource:

```
class RecurringInvestmentResource < SASC::Resource
  
  res_has_one_relationship :bank_link, BankLinkResource, settable_for: [:create],
                                                         settable_target_scope: lambda { |resource|
                                                           BankLink.for_user(resource.context[:current_user])
                                                         }
end
```             

#### Using #assign to customize how a field is set

If you have made a field settable, you can also customize how that information is mutated between entry in the client and how it's passed to the record. You can use the option `assign:` with a callable like a lambda or a proc. For example, here we are converting amount_cents from a string in the client into a `Money` object:

```
class RecurringInvestmentResource < SASC::Resource
  res_attribute :amount_cents, :string, settable_for: [:create, :update], assign: lambda { |resource, amt_cents|
    resource.record.amount_cents = SwellMoney.concrete_from_cents_amount(amt_cents)
  }
end
```

# Step 2: Hook It Up

Now that your resource and selectors have been created, it's time to hook them up to the overall app. 

### Restful Routes

Add the resources to the `config/routes.rb` file inside the `:api` namespace, with any restrictions as needed. Most likely you will only need the `index` and `show` methods.

```
namespace :api do
  # ...
  resources :samples, only: [:index, :show]
end
```
For a more complicated/CUD controller, you will need to include every method you want to enable inside the controller. If you have custom SASC actions, you will need to enable them within a block that acts on either a `member` or `collection` of resource objects. 

```
resources :recurring_investments, path: '/recurring-investments', only: [:index, :show, :create, :update, :destroy] do
  collection do
    post 'action/calculate-next-dates' => :calculate_next_dates
  end
end
```
Important things to note in this route:

1.   If there are underscores in the controller name (eg. market_analyses) you must include a `path:` attribute as a string, with dashes replacing the underscores of the name (eg. '/market-analyses').
2.   For any custom SASC actions, you will need to specify the post route as a string beginning with 'action/' and with any underscores replaced with dashes, then map it to a symbol of the action name (see `:calcuate_next_dates` above).
3.   As a rule, you should use the `only:` option and list all available CRUD actions for clarity, even if you are using the majority of the seven routes included with the Rails `resources` routing helper. SASC does not support `:new` or `:edit`, so we want to avoid creating those routes by mistake. 

### Vestigial Views

You may be able to remove the old controller's view files (commonly the .json.jbuilder files), assuming they are not being used elsewhere by other non-SASC views or controllers. Before removing the file, double check that you have defined all the necessary fields from that file in the SASC resource. 

The SASCBaseController includes instructions to render resources in `#index` and `#show`, so those view files are never needed and should be removed.

--

** INTERSTITIAL BREAK: THIS IS A GOOD TIME TO UPDATE YOUR TESTS! AND GO GET A SNACK. YOU DESERVE IT. **
--

Whew! That was a lot of server-side work. Now, it's time to convert the client.

# Step 3: Convert The Client


Converting or creating client-side SASC resources both follow the same basic steps. To convert the client, you will need the following basics:

* Define the resource inside the `resources.js` file to attach it to the Redux store/sagas/reducers etc.
* Attach the new resource to React components using WithResources 


## Resource Definitions, aka Where the Magic Happens

Creating an complete set of selectors, sagas, reducers, and actions for any resource is as easy as adding one line to one file. Whaaaaat? 😮 It's true! `resources.js` is the file that provides both the selectors and the actions for any given resource. 

Open `client/assets/javascripts/resources.js` and add a resource definition const for your new resource beneath the other `const`s. Some things to keep in mind: 

* If you added any CUD routes in the controller, you must enable them here using flags or else the actions will not be created.
* If you created a custom SASC action in the controller, add it here too. 
* Single-word actions can be defined by themselves, while multi-word actions must be defined as dash-separated strings. 
* When the optional `invalidation: true` flag is set on an action, it means that every time you call that action, the cache and index will be reset for that resource type.

```
# Basic Resource Definition (no custom action)
export const [sampleSelectors, sampleActions] = config.define('samples');

# Resource Definition including a custom action and CUD routes
export const [accountSelectors, accountActions] = config.define('accounts', {
  create: true,
  update: true,
  destroy: true,
  customSascActions: {
    close: { kind: 'individual', invalidation: true },
    'calculate-next-dates': { kind: 'collection' },
  },
});
```

For more information on what exactly this does, read through `client/assets/javascripts/resourceLib.js`.


## Component File Conversion

Once you have declared your resource definition, you are able to import those actions, selectors etc into your front-end component.

### Import WithResources and selectors
In the imports section of your component, get your component's selectors from the `resources.js` file:

```
# client/assets/javascripts/components/Samples.jsx

import { sampleSelectors } from 'resources';

import WithResources from 'components/shared/WithResources';
```

### <a name="convertingmapState"></a>Convert mapStateToProps to mapSelectorsToProps

`mapSelectorsToProps` is the SASC version of mapStateToProps. Instead of calling each selector with the state as input, you will be calling select() with the selector function as input, as well as any extra parameters to the selector (other than the state). The select() function inside `WithResources.js` will call that selector on state.

To convert from `mapStateToProps` to `mapSelectorsToProps`, go through each prop and convert every selector call to a new indirect `select` call:

```
import { otherSelector } from `selectors/somesuch`;

// OLD
function mapStateToProps(state) {
  return {
    samples: state.samples,
    otherStuff: otherSelector(state, "foo", "bar"),
  };
}
 
// NEW
function mapSelectorsToProps(select) {
  return {
    samples: select(sampleSelectors.getMany),
    otherStuff: select(otherSelector, "foo", "bar"),
  };
}
```

### Write selectors as necessary

If your `mapStateToProps` function was accessing state directly to get something other than a resource, then while switch to `mapSelectorsToProps` you should write a selector and use that instead:

```
// OLD component code

function mapStateToProps(state) {
  return {
    things: state.things
  };
}
 
// NEW selectors/things.js

export function getThings(state) { return state.things; }

// NEW component code

import { getThings } from `selectors/things`;

function mapSelectorsToProps(select) {
  return {
    things: select(getThings)
  };
}
```
 
### Set up WithResources
In order to properly use the new SASC resources, export the default component using `WithResources`, rather than React's `connect` function. `WithResources` is similar to `connect`, but it uses your new `mapSelectorsToProps` function to notice when resources need to be requested from the server.

If you need to dispatch actions, then `mapDispatchToProps` works exactly the same in `WithResources` as it does in `connect`.

When you are creating WithResources export at the end, use mapSelectorsToProps as the second argument, after the component:

```
// OLD
export default connect(		 
  mapStateToProps,
  mapDispatchToProps
)(Samples);

// NEW
export default WithResources(Samples, mapSelectorsToProps, mapDispatchToProps);
```

### Alternate approach: `safeConnect`

Instead of doing all the work above to use `WithResources`, you can use `safeConnect`. That allows you to leave your `mapStateToProps` largely unchanged, except for using your new selectors:

```
// OLD
import { connect } from `react-redux`;
import { otherSelector } from `selectors/somesuch`;

function mapStateToProps(state) {
  return {
    samples: state.samples,
    otherStuff: otherSelector(state, "foo", "bar"),
  };
}

export default connect(mapStateToProps)(Component);
 
// NEW
import { safeConnect } from `components/shared/WithResources`;
import { otherSelector } from `selectors/somesuch`;
import { sampleSelectors } from 'resources';

function mapStateToProps(state) {
  return {
    samples: sampleSelectors.getMany(state),
    otherStuff: otherSelector(state, "foo", "bar"), // Exactly the same as before
  };
}

export default safeConnect(mapStateToProps)(Component);
```

The disadvantage of `safeConnect` is that, while any resources requests are being made to the server, your component will only render `null`. In contrast, `WithResources` will let your component render even while resources are loading.

### Saga Conversions using `diligentSelect` and `runResourceProcess`

Saga conversions are a piece of cake with two brand-new SASC methods: 

* `diligentSelect` replaces the Redux saga `select` effect. It will keep trying to get the given resource from the API up to ten attempts before throwing an error. It can even be used on selectors that call SASC selectors indirectly. It is always safe to replace a regular `select` with `diligentSelect` because if no resources are requested then no extra calls will be made.

* `runResourceProcess` replaces `call` on API functions. It is necessary to create an action first that starts a SASC process (including create, update, destroy and custom SASC actions) and save it as a variable, then pass that variable to `runResourceProcess()`

Here is a quick guide on how to transform an existing saga into a SASC saga, or how to create a SASC saga from scratch.

```
// OLD:

export function * createOrUpdateRecurringInvestment(_action) {
  yield put(MODAL.loading());
  try {
    const existing = yield select(existingRecurringInvestment);
    const data = yield select(recurringInvestmentParams);
    const requester = existing ? api.recurringInvestments.update : api.recurringInvestments.create;
    const payload = yield call(requester, data);
    yield put({ type: 'RECURRING_INVESTMENT_CREATED', payload });
  } catch (e) {
    yield put({ type: 'RECURRING_INVESTMENT_FAILED', errors: e.errors });
  }
  yield put(MODAL.hide());
}

// NEW:

import { diligentSelect, runResourceProcess } from 'sagas/helpers';

export function * createOrUpdateRecurringInvestment(_action) {
  yield put(MODAL.loading());
  try {
    const existing = yield diligentSelect(existingRecurringInvestment);
    const data = yield diligentSelect(recurringInvestmentParams);
    const idIfExisting = existing ? { id: existing.id } : {};
    const requestPayload = { ...idIfExisting, type: 'recurring-investments', ...data };

    const action = recurringInvestmentActions[existing ? 'update' : 'create'](requestPayload);
    const payload = yield runResourceProcess(action);
    yield put({ type: 'RECURRING_INVESTMENT_CREATED', payload });
  } catch (e) {
    yield put({ type: 'RECURRING_INVESTMENT_FAILED', errors: e.errors });
  }
  yield put(MODAL.hide());
}
```

Please note that the `idIfExisting` constant above is only necessary on `#update` actions. If this was a pure creation saga the id would be not be supplied. The `const action` line declares the SASC action we want to emit and the `const payload` line actually calls it using `runResourceProcess`. 

## Step 4: Testing

### Server-Side Testing

#### Required Helper Methods

SASC makes use of certain helper methods in testing that you may find useful when creating or converting existing server-side controller spec tests. 

* `render_views`: all SASC controller specs should begin by calling the `render_views` helper method. This is a Rails helper that disables an optimization that stops rendering from happening during tests and helps us ensure that all our methods are returning the correct information that the client needs to render the resource.
* `set_sasc_request_headers`: all SASC controller specs should call this method in the before block to prevent SASC from rejecting requests for incorrect/insufficient request headers. 

#### Optional Helper Methods 

In addition to the required helpers that make the SASC tests work, there are optional helpers to be aware of that might help make SASC testing easier. 

* `json` and `json_if_present`: shortcuts to parse `response.body` as JSON after a request is made. `json` will error if there is no response body, and `json_if_present` will return nil.

* `be_sasc_error`: this is an rspec expectation defined in `sasc_helpers.rb` that allows you to declare the expected error code and/or any other error keys and values. For example, you could use it to make sure that a request with invalid parameters returns the appropriate error:

	```
	context 'with invalid parameters' do
	  # invalid params for schedule and timing
	  let(:schedule) { 'weekly' }
	  let(:timing_params) { { dayOfMonth: 'the_first' } }
	
	  # test that an INVALID FIELD error is returned and points to the offending value
	  it 'returns errors about the investment' do
	    subject
	    expect(json).to be_sasc_error(code: "__INVALID_FIELD_VALUE__", source: { pointer: '/data/attributes/dayOfWeek'})
	  end
	end
	```



#### Setting the SASC params

The best resource for information on how SASC expects to receive requests can be found in the Swell API Standard Convention file in the `docs/` folder of the codebase. That file includes examples of headers, requests, and JSON responses to assist in mocking those requests for testing.

The biggest change from non-SASC to SASC resources is that the request parameters change from a less-formal controller-specific JSON request syntax to a more particular SASC JSON syntax. Because all requests must arrive in the standard SASC format, you will need to mock this format in the tests. For example, mocking a create request might look like this. Important things to notice are:

* the params now use the SASC-required data/attributes/relationships structure
* params are required for custom SASC actions because its arguments hash is required 
* the keys are now camel cased
* ids must be strings

```
describe '#create' do
	subject { post :create, params: create_params.dup, as: :json }

	let(:bank_link) { user&.bank_links&.first }
	let(:bank_link_id) { bank_link&.id }
	let(:schedule) { 'monthly' }
	let(:amount_cents) { 25_00 }
	let(:create_params) do
	  {
	    data: {
	      type: 'recurring-investments',
	      attributes: {
	        schedule: schedule,
	        amountCents: amount_cents,
	      },
	      relationships: {
	        bankLink: { data: { id: bank_link_id.to_s, type: 'bank-links' } }
	      }
	    },
	  }
	end
end
```
When mocking a JSON request objects, it's important to remember that `type` is required for `#create` and `#update`, while `id` is required for `#update` but prohibited for `#create`. 

**Custom SASC action params must include an arguments hash**, which will be empty if the action has no arguments. For example: `subject { get :calculate_next_dates, as: :json, params: { arguments: {} } }`

### Client-Side Testing

Client-side testing with SASC relies on a simulated state with resources preloaded as if just retrieved from the server.

#### Mocking state with resources using `buildResourceState`

In testing, it may be necessary to simulate the state having a certain set of resources, including empty returned indexes. resourceLib provides a method called `buildResourceState` which can help construct this temporary testing state.

**The default use of `buildResourceState` is to only use its first argument.** This argument simulates that the program made a getMany request (or requests, if there is more than one type of resource) to the server and received these resources in order in return. 

```
 describe('when user has a recurring investment', function() {
  beforeEach(function() {
    state = {
      account: { id: 43 },
      ...buildResourceState([
        {
          type: 'recurring-investments',
          id: 42,
          amountCents: 4534,
          schedule: 'weekly',
          dayOfMonth: null,
          dayOfWeek: 'monday',
          relationships: { accounts: { data: { type: 'accounts', id: 43 } } },
        },
      ]),
    };
  });
});
```


**The second argument of buildResourceState** is used to simulate making an index request for any kind of resource type where the request returns a specific list of IDs. In testing, this is most commonly user to simulate returning an empty array, as if there are no resources returned for that query.

```
describe('when user does not have a recurring investment', function() {
	beforeEach(function() {
 	 state = {
 	   account: { id: 43 },
 	   ...buildResourceState([], { 'recurring-investments': [] } ),
	  };
	});
});
```
This test simulates a state where there is an account, but a getMany request for all recurring investments returns an empty array, as if the user had an account but no recurring investment. It is also possible to pass ids into the second argument's array if needed.


### Cleanup/Optional

* Remove any duplicate data from `app/controllers/pages_controller.rb` and `app/views/pages/homepage.json.jbuilder`.
* In order to accommodate the changes above, you may have to adjust other things in the app. For example, you may have to move methods from helpers into decorators so that the Resource class can reach them.
