# Swell API Standard Convention

This is the formal definition of SASC as a protocol.

You might also be interested in:

* [The server-side Rails SASC library reference](RailsSASC.md)
* [The client-side Redux resourceLib reference](ReduxSASC.md)
* [The SASCification guide](SASCificationGuide.md)

## Table of Contents

<!-- This table of contents can be automatically regenerated by yarn run docs -->

<!-- toc -->

  * [What is this document?](#what-is-this-document)
  * [What isn't this document?](#what-isnt-this-document)
- [Inspiration](#inspiration)
  * [SASC incorporates some ideas from RESTful HTTP](#sasc-incorporates-some-ideas-from-restful-http)
    + [But SASC is not HATEOAS](#but-sasc-is-not-hateoas)
    + [SASC is not completely RESTful](#sasc-is-not-completely-restful)
  * [SASC uses JSON-API-ish documents](#sasc-uses-json-api-ish-documents)
    + [But SASC is not fully compatible with JSON API](#but-sasc-is-not-fully-compatible-with-json-api)
- [Conventions](#conventions)
- [Headers](#headers)
  * [Requests](#requests)
  * [Responses](#responses)
  * [Versioning](#versioning)
- [URLs](#urls)
  * [Collection URLs](#collection-urls)
    + [`GET` on Collection URL](#get-on-collection-url)
      - [Inclusions](#inclusions)
      - [Pagination](#pagination)
      - [Sorting](#sorting)
      - [Filters](#filters)
    + [`HEAD` on Collection URL](#head-on-collection-url)
    + [`POST` on Collection URL](#post-on-collection-url)
  * [Single Resource URLs](#single-resource-urls)
    + [`GET` on Single Resource URL](#get-on-single-resource-url)
    + [`HEAD` on Single Resource URL](#head-on-single-resource-url)
    + [`PATCH` on Single Resource URL](#patch-on-single-resource-url)
    + [`DELETE` on Single Resource URL](#delete-on-single-resource-url)
  * [Action URLs](#action-urls)
- [SASC Documents](#sasc-documents)
  * [Resource Objects](#resource-objects)
  * [Relationship Objects](#relationship-objects)
  * [`included` Resource Objects](#included-resource-objects)
  * [Error Objects](#error-objects)
  * [Meta Objects](#meta-objects)
- [Error handling](#error-handling)
  * [Standard error codes](#standard-error-codes)
    + [Invalid field value](#invalid-field-value)
    + [Unknown field](#unknown-field)
    + [Invalid query parameter value](#invalid-query-parameter-value)
    + [Unknown query parameter](#unknown-query-parameter)
    + [Invalid action argument value](#invalid-action-argument-value)
    + [Missing required action argument](#missing-required-action-argument)
    + [Unknown action argument](#unknown-action-argument)
    + [Invalid request document content](#invalid-request-document-content)
    + [Invalid request document format](#invalid-request-document-format)
    + [Bad URL pattern](#bad-url-pattern)
    + [Bad method](#bad-method)
    + [Bad Individual Resource URL id](#bad-individual-resource-url-id)
    + [Authentication needed](#authentication-needed)
    + [Permission denied](#permission-denied)
    + [Unknown API version](#unknown-api-version)
    + [Incompatible API version](#incompatible-api-version)
    + [Bad Content-Type header](#bad-content-type-header)
    + [Bad Accept header](#bad-accept-header)
    + [Bad header](#bad-header)
    + [Internal error](#internal-error)
- [Documentation](#documentation)

<!-- tocstop -->

### What is this document?

This document describes a standard for communication between the Swell server and Swell client(s). Let's call it the **"Swell API Standard Convention"**, or **"SASC"** for short (pronounced "sassy").

### What isn't this document?

*This document does not necessarily describe the only standard in use*: We may use other incompatible conventions at Swell. For example, maybe in the future we will add a GraphQL endpoint. However, whenever you see the `X-SASC` header on a request or response, you can be sure that this specification should apply.

*This document does not describe authentication or authorization*: This specification is orthogonal to the use of `Authorization` headers, authentication cookies, permission systems, etc.

*This document is not about the Swell API in particular*: The actual routes and data provided by the Swell server are not described by this document. Only the structure of communication is here, not its content.

*This document is not about implementation in Swell*: How we actually go about writing support for the server and client is outside the domain of this specific document. However, ease of implementation is a very important factor to consider, so if you think this spec can be changed in a way to make life easier, see the next item.

*This document is not set in stone*: You, yes you, can make suggestions about changing this standard! Please help us make SASC better. Of chief concern, in no particular order, are:

* Bandwidth
* Latency
* Cacheability
* Ease of implementation
* Ease of debugging
* Backwards compatibility as the API evolves

## Inspiration

### SASC incorporates some ideas from RESTful HTTP

SASC follows the the [HTTP 1.1 protocol described in RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html). In general, if RFC 2616 allows something and this document doesn't explicitly forbid or contradict it, then that thing is allowed.

SASC is also RESTful in the sense that it follows the [Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html) up to level 2. Unlike HTTP, there's no agreed-upon precise spec for what it means to be RESTful, but SASC has the following generally-understood-to-be-RESTful attributes:

* Each resource provided has a specific URL
* To retrieve that resource, you make a GET request at that URL
* To manipulate a resource, you use other HTTP verbs: POST, PUT, PATCH, DELETE
* If an operation is successful, the appropriate 2xx status code is used
* On errors, other status codes are returned, with meanings consistent with the HTTP spec

#### But SASC is not HATEOAS

HATEOAS is level 3 of the Richardson Maturity Model, and it basically states that it should be possible to navigate from a site's root to any other resource in the system by following hyperlinks between resources.

However, SASC does not use hyperlinks. In other words, clients do need to know, in advance, the URL patterns for the resources they want to use.

#### SASC is not completely RESTful

SASC allows for RPC-ish "Action URLs" which (arguably, depending on who you ask) would not exist in a purely RESTful system. They are clearly marked with `/action/` in the URL so that their idiosyncratic nature stands out.

### SASC uses JSON-API-ish documents

A standard named [JSON API](http://jsonapi.org/), defines, among other things, a [document structure](http://jsonapi.org/format/#document-structure) for request and response bodies. SASC uses a very similar (but incompatible!) format.

#### But SASC is not fully compatible with JSON API

SASC does not follow the other parts of the JSON API spec. It does not support the same query arguments and query argument encoding, require the same headers, or make the same guarantees about status codes and URLs.

## Conventions

The key words “MUST”, “MUST NOT”, “SHOULD”, “SHOULD NOT”, and “MAY” in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

## Headers

### Requests

All requests MUST have the following headers:

* `Accept`: MUST allow for `application/json` format. The catch-all `*/*` is permissible.
* `Content-Type` (if request has body): MUST have the value `application/json`.
* `X-SASC`: MUST have the value `1.0.0`.
* `X-SASC-API-Version`: MUST be a [semver](http://semver.org) indicating the version of the server's API that the client wishes to use.
* `X-SASC-Client`: SHOULD have the client name, the client version, and the client build time, separated by spaces, e.g. `some-fancy-client 1.3.12 1509656888`. The client name MUST consist entirely of lowercase letters, numbers, and dashes. The client version MUST be a semver, but has no correlation with the API version and is not as strictly defined for the purposes of this spec. The build time MUST be a non-negative integer, and MUST increase by at least 1 for every new release; for example, it could be the UNIX timestamp of when the release was packaged.

Headers SHOULD be used in requests for supplying CSRF tokens and authentication keys; these SHOULD NOT be embedded in the body of the request.

### Responses

All responses MUST have the following headers:

* `Content-Type` (if response has body, or hypothetical body for `HEAD` requests): MUST have the value `application/json`.
* `X-SASC`: MUST have the value `1.0.0`.
* `X-SASC-API-Version`: MUST be an semver indicating the version of the server's API that was used for this response. This MUST be greater than or equal to the version specified in the request's `X-SASC-API-Version` header (unless the response has an error about the client's `X-SASC-API-Version` header).

### Versioning

The major version of `X-SASC-API-Version` MUST increment for any deployment with a backwards-incompatible change, e.g. fields being removed or changed. If possible, you SHOULD avoid making such changes. For example, instead of changing a field's format, create a new field with the new format, and leave the old field as-is until you are certain that no clients remain that depend on the old field.

The minor version of `X-SASC-API-Version` MAY increment for any deployment with new fields or features, and the patch version MAY increment for any deployment with minor bug-fixes and similar transparent improvements. Because backwards-incompatible changes increment the major version regardless of severity, the API version SHOULD NOT be interpreted as a quantitative measure of the difference between two deployed versions, even roughly.

If the `X-SASC-API-Version` header isn't enough, the `X-SASC-Client` header provides a last-ditch way for servers to tailor their responses to different clients. You SHOULD prefer using the API version header for this.

## URLs

URL path parts (i.e. the elements of the URL path separated by slashes) MUST consist entirely of lowercase letters and/or numbers, with words separated by dashes.

Remember that URLs must be [properly encoded](https://tools.ietf.org/html/rfc3986#section-2) or risk being misinterpreted by various systems. You SHOULD use a URL encoding library when creating URLs dynamically.

URL query parameter names (i.e. the `x` in `/api/foo?x=y`) SHOULD be in lower camel case, rather than separated by dashes.

URL query parameter values MUST be valid [JSON](http://json.org) expressions. In particular, this means that you MUST wrap string values in double-quotes, which are encoded in URLs as `%22`. For example, `/api/people?filter[name]=%22Rasputin%22`.

All URLs MUST contain the part `api`. This can be preceded by any number of other parts (or none), but any parts after `api` MUST match one of the patterns below.

URLs MAY support various different HTTP methods. The API documentation SHOULD clearly document which methods are supported at which URL patterns.

### Collection URLs

Example path: `/blah/api/amazing-things`

Collection URLs MUST have one path element after `api`, which must be the type of the resource. 

The following HTTP methods MAY be supported:

#### `GET` on Collection URL

Retrieves a list of resources.

Example:

```
>>>
GET /blah/api/amazing-things HTTP/1.1
Accept: application/json
X-SASC: 1.0.0
X-SASC-API-Version: 371.2.0
X-SASC-Client: some-fancy-client 1.3.12 1509656888

<<<
200 OK
Content-Type: application/json
X-SASC: 1
X-SASC-API-Version: 371.3.1

{
    "data": [
        {
            "type": "amazing-things",
            "id": "123",
            "attributes": {
                "color": "green",
                "shape": "prism"
            },
            "relationships": [
                "creator": {
                    "data": { "type": "people", "id": "55" }
                },
                "seenLocations": {
                    "data": [
                        { "type": "places", "id": "12" },
                        { "type": "places", "id": "27" },
                    ]  
                }
            ]
        }
    ],
    "included": {
        "people": [
            {
                "type": "people",
                "id": "55",
                "attributes": {
                    "name": "Jane Person",
                    "dob": "1980-01-01"
                },
                "relationships": {
                    "creations": {
                        "data": [
                            { "type": "amazing-things", "id": "123" },
                        ]
                    }
                }
            }
        ],
    },
    "meta": {
        "__total__": 1
    }
}
```

If request is successful and passes preconditions, server MUST reply with an SASC document with a `data` element containing an array of resource objects with the same `type` as in the URL, and status code `200 OK`.

As an exception to the above, if the request is [conditional](https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests) then the server SHOULD try to determine if the client already has the most recent representation cached. If it does, the server SHOULD reply with `304 Not Modified` and an empty response body.

The server MAY limit which resources are returned based on permissions, roles, or similar restrictions.

##### Inclusions

The response MAY have an `included` field with additional resource objects, such as (but not limited to) objects identified in relationships in the primary objects.

##### Pagination

The client MAY supply a `page[limit]` query parameter with a positive integer value; if it does so, the server MUST NOT return more resources in `data` than the limit allows. The client also (with or without a limit) MAY supply a `page[offset]` query parameter with a positive integer value; if it does so, the server MUST skip that number of resources. Example:

`GET /blah/api/amazing-things?page[limit]=50&page[offset]=100`

The server MAY have a maximum limit, so that if the client supplies a `page[limit]` query parameter that is too high, the server responds with an error. The server MAY also treat this maximum limit as the default limit, so that a limited number of resources is returned even if the client doesn't supply a `page[limit]` query parameter. Maximum and default limits SHOULD be described in the API documentation. Changes to the default/maximum limit MUST be considered backwards-incompatible changes for the purposes of API versioning.

Similarly, the server MAY have a maximum offset, such that if too high an offset parameter is given, the server responds with an error. The maximum offset SHOULD be described in the API documentation. The maximum offset MAY be zero if the server does not want to permit offsets at all.

If no `page[offset]` is provided, the server MUST act with a default offset of zero. If the `page[offset]` is greater than the total number of available resources, but the request is otherwise valid, the server MUST return a response with an empty array for `data`.

Note that pagination with `page[offset]` and `page[limit]` does not guarantee a consistent full read; if resources are created, deleted, or modified in between page loads, then the client may miss some records between pages, or it may see duplicate records on adjacent pages.

A meta field `__total__` with the total number of available resources (regardless of `page[limit]` and `page[offset]`) SHOULD be provided if applicable.

##### Sorting

The server MAY support sorting the resources to be returned through the use of the `sort` query parameter:

`GET /blah/api/amazing-things?sort=[%22color%22]`

The sort parameter MUST be a JSON array of strings, each of which is an argument to sort on. Each argument MUST consist only of upper and lower case letters, numbers, and underscores, with an optional dash prefix that indicates descending sort order. Each argument SHOULD be in lower camel case. If an argument represents an attribute, they SHOULD have the same name as that attribute. All supported sort arguments SHOULD be described in the API documentation.

The sort order for each argument MUST be ascending unless the argument is prefixed by a dash, in which case it MUST be descending.

If multiple sort arguments are given, they SHOULD be applied in the order specified.

The server MAY have an upper limit on the number of sort arguments accepted, and return an error if this limit is exceeded. Such limits SHOULD be described in the API documentation.

If no `sort` query parameter is supplied, the server MAY use a default sorting rule.

##### Filters

The server MAY support filtering the resources to be returned through the use of `filter[X]=Y` query parameter, where `X` is the filter name and `Y` is a JSON expression.  For example, if we were only interested in red things we might make the request `GET /blah/api/amazing-things?filter[paintColor]=%22red%22`. All filter arguments MUST be optional.

The filter name MUST consist only of upper and lower case letters, numbers, and underscores, and SHOULD be in lower camel case. If the filter represents an attribute or relationship, it SHOULD have the same name. The filter name SHOULD NOT be plural, even if the filter logically accepts multiple values, unless the filter has the same name as a relationship with a plural name.

Filters SHOULD be described in the API documentation with the types of JSON expressions they accept. If a filter allows matching against many possible values, it SHOULD accept an array and MAY optionally accept a single value not wrapped in an array; this behavior SHOULD be described in the API documentation.

The server MUST at a minimum support the `filter[id]=X` query parameter, where X is an array of resource ids (which must be strings). For example, to retrieve resources with ids 1, 3, and 5:

`GET /blah/api/amazing-things?filter[id]=[%221%22,%223%22,%225%22]`

(Decoded: `GET /blah/api/amazing-things?filter[id]=["1","2","3"]`)

For filtering on relationships, the specification is stricter. If the server provides a filter with the same name as a relationship, the filter value MUST be a JSON object. For reference, the left curly brace `{` is URL encoded as `%7B`, the right curly brace `}` is encoded as `%7D`, and the colon `:` is encoded as `%3A`. The object must have keys equal to resource types, and each key's value must be an array of string ids. For example, to request all amazing things created by Person 5, Person 8, or Robot 27:

`GET /blah/api/amazing-things?filter[creator]=%7B%22people%22%3A[%225%22,%228%22],%22robots%22%3A[%2227%22]%7D`

(Decoded: `GET /blah/api/amazing-things?filter[creator]={"people":["5","8"],"robots":["27"]}`)

For has-many relationships, each additional id listed in the filter MUST expand the search rather than contracting it, i.e. a resource should be included in the result `data` even if it is only related to one of the listed ids.

#### `HEAD` on Collection URL

Behaves like `GET` would on the same URL, but MUST return an empty response body. The `Content-Type` header MUST still be sent if the response status is `200 OK`.

#### `POST` on Collection URL

Creates a new resource.

Example:

```
>>>
POST /blah/api/amazing-things HTTP/1.1
(... headers ...)

{
    "data": {
        "type": "amazing-things",
        "attributes": {
            "color": "orange",
            "shape": "cuboid"
        },
        "relationships": [
            "seenLocations": {
                "data": [
                    { "type": "places", "id": "9" }
                ]  
            }
        ]
    }
}

<<<
201 Created
(... headers ...)

{
    "data": {
        (... the new resource ...)
    }
}
```

Client MUST provide a SASC document with a single resource object in the `data` element, except it MUST NOT have an `id` field. The server MAY permit some attributes to be omitted as well, if they have sensible default values.

The server MAY choose not to represent some incoming attributes or relations in the resource it returns. For example, the client might specify a `plaintextPassword` attribute for a new `users`-type resource, which the server chooses not to directly store. Such write-only attributes SHOULD be explicitly pointed out in the API documentation.

The server also MAY choose some attributes to be immutable. For example, a `movie` resource might have a `averageRating` field, which is never provided directly by the client but is instead calculated by the server internally. Such read-only attributes SHOULD be explicitly pointed out in the API documentation. Client attempts to write to such an attribute MUST result in `_invalid_field_value` errors.

If successful, server MUST reply with status code `201 Created` and a SASC document with the newly created document in the `data` element. This document SHOULD have an `id` field, unless it is for a transient resource.

The response MAY have an `included` field with additional resource objects, such as (but not limited to) objects identified in relationships from the primary object.

### Single Resource URLs

Example path: `/blah/api/amazing-things/57`

Single Resource URLs MUST have two path elements after `api`, the resource type and a resource id.

The same URL MUST refer to the same resource, regardless of the identity or permissions of the client making the request. If a resource is not authorized to be accessed, return an error as described in the "Errors" section.

A resource SHOULD NOT be accessible at more than one path or under more than one resource type. The `type` of a resource should be considered an immutable part of its identity, just like its `id`.

The following HTTP methods MAY be supported:

#### `GET` on Single Resource URL

Retrieves a single resource.

Example:

```
>>>
GET /blah/api/amazing-things/57 HTTP/1.1
(... headers ...)

<<<
200 OK
(... headers ...)

{
    "data": {
        "type": "amazing-things",
        "id": "57",
        "attributes": {
            (... the resource's attributes ...)
        },
        "relationships": {
            (... the resource's relationships ...)
        }
    },
    "included": {
        (... other resources that the server believes might be relevant ...)
    }
}
```

If successful, server MUST reply with an SASC document with a `data` element containing the resource object with the same `type` and `id` as in the URL, and status code `200 OK`.

As an exception to the above, if the request is [conditional](https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests) then the server SHOULD try to determine if the client already has the most recent representation cached. If it does, the server SHOULD reply with `304 Not Modified` and an empty response body.

The response MAY have an `included` field with additional resource objects, such as (but not limited to) objects identified in relationships in the primary object.

Note that attributes and relationships may still be implicitly hidden from clients, e.g. due to having limited permissions.

#### `HEAD` on Single Resource URL

Behaves like `GET` would on the same URL, but MUST return an empty response body. The `Content-Type` header MUST still be sent if the response status is `200 OK`.

#### `PATCH` on Single Resource URL

Updates a single resource.

Example:

```
>>>
PATCH /blah/api/amazing-things/57 HTTP/1.1
(... headers ...)

{
    "data": {
        "id": "58",
        "type": "amazing-things",
        "attributes": {
            "color": "turquoise",
        },
        "relationships": [
            "seenLocations": {
                "data": [
                    { "type": "places", "id": "99" }
                ]  
            }
        ]
    }
}

<<<
200 OK
(... headers ...)

{
    "data": {
        (... the complete resource after updates have been applied ...)
    }
}
```

If successful, server MUST reply with status code `200 OK` and a SASC document with a `data` element containing the *complete* resource in its new state.

Request MUST have a body consisting of a SASC document with a `data` element containing any attributes and relationships to change. The new resource MUST have the same `id` and `type` as before.

The response MAY have an `included` field with additional resource objects, such as (but not limited to) objects identified in relationships in the primary object.

The client MAY omit any attributes or relationships, or it MAY omit the `attributes` or `relationships` fields entirely. Any attributes or relationships omitted by the client MUST retain their original value. However, if an attribute or relationship is supplied as `null`, the server MUST interpret that as an attempt to set the actual value of that attribute or relationship to `null`.

Note that setting a relationship to `null` is not the same as deleting the associated object. However, the server MAY choose to delete associated objects if appropriate. Such behavior SHOULD be described in the API documentation.

#### `DELETE` on Single Resource URL

Deletes a single resource.

Example:

```
>>>
DELETE /blah/api/amazing-things/57 HTTP/1.1
(... standard headers ...)

<<<
204 No Content
(... headers ...)
```

Request MUST have no body.

If successful, server MUST reply with the status code `204 No Content` and no response body.

### Action URLs

Example paths:

* `/blah/api/amazing-things/action/do-the-twist`
* `/blah/api/amazing-things/47/action/do-the-twist`

Action URLs are used for behavior that doesn't map neatly to the standard URL patterns and methods above.

Example request:

```
>>>
POST /blah/api/amazing-things/action/send-report HTTP/1.1
(... headers ...)

{
    "arguments": {
        "recipient": "user@domain.com",
        "groupResultsBy": "color"
    }
}

<<<
202 Accepted
(... headers ...)

{
    "result": {
        "status": "queued",
        "reportLength": 17843
    }
}
```

Action URLs are like Collection URLs or Individual Resource URLs, but followed by two additional parts: the string `action` and an action name. The action name MUST consist only of words formed of lowercase letters, separated by dashes, and SHOULD grammatically be in the form of an imperative statement or verb.

Action URL requests MUST use the `POST` method.

When designing an API, prefer using regular Collection URLs or Individual Resource URLs instead of Action URLs. Only use Action URLs if you can't sensibly map the behavior you want to a standard method at a standard URL.

An Action URL does not necessarily imply the existence of any available methods on the Collection URL or Individual Resource URL it is affixed to. For example, you MAY provide support for `POST /api/spacecraft/action/launch` without supporting any methods at `/api/spacecraft/`.

Requests MUST have a SASC document in the body, which MUST have an `arguments` field. The `arguments` field MUST be an object with parameters for the action; its values can be any valid JSON value. The server SHOULD respond with an error if it receives invalid `arguments`.

The server MAY permit some fields within `arguments` to be optional, either generally or in specific contexts. The API documentation SHOULD explain which fields are optional and when. If all `arguments` fields are optional, the client nonetheless MUST provide an `arguments` field, even if its value is only an empty object.

The request MAY also have a `meta` field.

If successful, the server MUST respond with either the status code `200 OK` (if the action was performed before the response was sent), or `202 Accepted` (if the action will be performed in the background).

The response MUST have a SASC document, which MUST have either a `results` or an `errors` field. The `results` field, if supplied, MUST be an object with any additional information about the action performed. The `results` object MAY be empty. The client MUST safely ignore any unexpected fields in the `results` object.

## SASC Documents

(SASC documents are very similar to [JSON API documents](http://jsonapi.org/format/#document-structure). The most significant difference is the lack of `links` fields and the addition of the `arguments` and `results` fields.)

The body of any request or response, *if provided*, MUST be a valid SASC document as described here. The document MUST be a [JSON](http://json.org/) object.

The keys in objects in SASC documents MUST consist only of upper and lower case letters, numbers, and underscores. This applies no matter how deeply nested the object is.

All application-defined keys (i.e. relationship keys, attribute keys, argument keys, result keys, meta keys, and keys appearing in nested objects in attributes) MUST NOT be the same as any JSON key defined in this document (e.g. `id`, `type`, `meta`, `data`, `arguments`, etc.) and MUST NOT start or end with an underscore.

Object keys SHOULD be in "lower camel case", i.e. only have upper and lower case letters, and start with a lower case letter.

SASC documents MUST consist of only the following fields:

* `arguments`: Used for action requests, an object containing arbitrary JSON values.
* `result`: Used for action responses, an object containing arbitrary JSON values.
* `data`: The "primary" resource object, or array of resource objects, as described below.
* `included`: An object containing additional resource objects, as described below.
* `errors`: An array of error objects, as described below.
* `meta`: A meta object, as described below.

One of the `data`, `errors`, or `result` fields MUST be present in every response. The `meta` and `included` fields MAY be present in responses, as described in the URL patterns above.

Requests MUST have either a `data` field or an `arguments` field, and MAY supply a `meta` field. It MUST NOT supply any other fields.

### Resource Objects

Resource objects MUST have the following fields:

* `id`: A unique identifier for the resource. Resource ids MUST be strings. A resource id MUST consist only of lowercase letters, numbers, and dashes. They SHOULD be non-meaningful i.e. not semantic. The advantage there is that resources keep the same URL no matter what, whereas e.g. an "account number" or similar attribute might conceivably change.
* `type`: The name of the resource's type. Resource types MUST consist only of words formed of lowercase letters, separated by dashes. Resource types SHOULD be plural, e.g. `awesome-things` is fine but `awesome-thing` is not recommended.

Additionally, resource objects MAY have any of the following fields:

* `attributes`: An object containing the data specific to the resource. Values can be any valid JSON, but SHOULD NOT include information referencing or copied from other resources.
* `relationships`: An object describing references from this resource to others (or vice versa). Each value MUST be a "relationship object" as described below.
* `meta`: A meta object as described below.

Clients MUST safely ignore any unknown fields in `attributes`, `relationships`, or `meta` in SASC documents received from the server.

The keys of `attributes` and `relationships` MUST NOT overlap in the same resource.

### Relationship Objects

Relationship objects MUST have a `data` field, which MUST contain one of the following values:

* For to-one relationships:
  * `null` if relationship is empty
  * An object which MUST have the `type` and `id` fields of the related object, and MAY have a `meta` field.
* For to-many relationships:
  * `[]`, the empty array, if relationship is empty
  * An array of objects, each of which MUST have the `type` and `id` fields of a related object, and MAY have a `meta` field.

A given relationship SHOULD reliably either be to-one or to-many.

### `included` Resource Objects

The `included` top-level field, if provided, MUST be an object with resource types as keys and arrays of resource objects as values. The resource objects in each array MUST have a `type` matching the corresponding key.

### Error Objects

Each error object MUST have a `code` field, which names the error in a machine-readable context. The `code` MUST be a string consisting only of uppercase letters, numbers, and underscores, e.g. `INSUFFICIENT_VESPENE_GAS`. The code MUST start with an uppercase letter. An exception to this is the reserved error codes described in the spec (e.g. `__INVALID_FIELD_VALUE__`), which MUST be wrapped with double underscores. Application-specific error codes MUST NOT start with underscores.

Error objects MAY also have any of the following fields:

* `subcode`: A string which describes the error more specifically in a machine-readable context. The subcode MUST consist of uppercase letters, numbers, and underscores, and MUST start with an uppercase letter. Clients MUST safely ignore unknown or missing `subcode` values.
* `id`: A string which serves as a unique identifier for this particular occurrence of the problem. If supplied, this string MUST consist only of upper and lower case letters, numbers, and dashes.
* `title`: A short human-readable summary of the problem, which SHOULD NOT change from occurrence to occurrence.
* `detail`: A human-readable explanation of the problem, which MAY have information specific to this occurrence.
* `source`: An object describing the source of the problem, which MUST have   exactly one of the following fields:
  * `pointer`: A JSON Pointer (as described in [RFC6901](https://tools.ietf.org/html/rfc6901)) to the associated entity in the request document (e.g. `/data` for a primary data object, or `/data/attributes/title` for a specific attribute).
  * `parameter`: A string with the name of the URL query parameter which caused the issue (e.g. `filter[paint-color]`).
  * `header`: A string with the name of the invalid HTTP request header.
* `meta`: A meta object as described below

### Meta Objects

An object containing any additional information that doesn't belong elsewhere. Values can be any valid JSON. Clients and servers MUST safely ignore any fields in `meta` that they do not understand.

Meta fields wrapped with double underscores, e.g. `__total__`, are reserved for the uses described in this specification. Application-specific meta fields MUST NOT start or end with an underscore.

## Error handling

When a request is unsuccessful, the server SHOULD respond with an appropriate 4xx or 5xx status code and a response body containing a SASC document with an `errors` field containing relevant error objects.

Each error code MUST correspond with one and only one HTTP status code. The server MUST use the corresponding HTTP status code when returning errors with that error code. The server MUST NOT return multiple errors in a single response that have contradictory associated HTTP status codes.

Responses SHOULD NOT use WebDAV-specific HTTP status codes, e.g. `423 Locked`.

The server MAY stop processing at any time to return errors. In other words, if a request has three serious problems, the server MAY respond with only the error objects relevant to one or two of the problems.

The application SHOULD have useful error codes for its own domain-specific problems, and such codes MUST have an appropriate corresponding HTTP status code. If you're unsure which HTTP status code to use, `400 Bad Request` is a reasonable default choice.

### Standard error codes

The common problems described below SHOULD be handled as described:

#### Invalid field value

To be used when the given content for an attribute or relationship in a request body is not valid, e.g. when a required attribute is absent, when an attribute is the wrong type, when an attribute fails other validations such as minimum length, when a relationship id does not reference a valid resource, etc.

* HTTP status: `400 Bad Request`
* Error object `code`: `__INVALID_FIELD_VALUE__`
* Error object `source`: SHOULD be `{ "pointer": "P" }` where P is a pointer to the invalid field (e.g. `/data/attributes/title` or `/data/relationships/category`)
* Error object `title`: SHOULD explain which validations failed in a human-readable way

Example:

```
>>>
POST /blah/api/amazing-things HTTP/1.1
(... headers ...)

{
    "data": {
        "type": "amazing-things",
        "attributes": {
            "color": "orange",
            "shape": 7
        }
    }
}

<<<
400 Bad Request
(... headers ...)

{
    "errors": [
        {
            "code": "__INVALID_FIELD_VALUE__",
            "source": { "pointer": "/data/attributes/shape" },
            "title": "Incorrect type"
        }
    ]
}
```

#### Unknown field

To be used when a given attribute or relationship is not recognized by the server for the given resource type.

* HTTP status: `400 Bad Request`
* Error object `code`: `__UNKNOWN_FIELD__`
* Error object `source`: SHOULD be `{ "pointer": "P" }` where P is a pointer to the unknown field (e.g. `/data/attributes/wrongAttribute` or `/data/relationships/wrongCategory`)

#### Invalid query parameter value

To be used when a URL query parameter's value is not valid, e.g. `/api/cars?filter[paintColor]=%22Australia%22`.

* HTTP status: `400 Bad Request`
* Error object `code`: `__INVALID_QUERY_PARAMETER_VALUE__`
* Error object `source`: SHOULD be `{ "parameter": "P" }` where P is the parameter name

#### Unknown query parameter

To be used when a URL query parameter is not recognized by the server for this URL, e.g. `/api/cars?filter[protagonist]=%22Hiro%22`.

* HTTP status: `400 Bad Request`
* Error object `code`: `__UNKNOWN_QUERY_PARAMETER__`
* Error object `source`: SHOULD be `{ "parameter": "P" }` where P is the parameter name

#### Invalid action argument value

To be used when an action request body includes an argument value that is not valid.

* HTTP status: `400 Bad Request`
* Error object `code`: `__INVALID_ACTION_ARGUMENT_VALUE__`
* Error object `source`: SHOULD be `{ "pointer": "P" }` where P is a pointer to the invalid argument (e.g. `/arguments/priority`)

#### Missing required action argument

To be used when an action request body does not have a necessary argument ield.

* HTTP status: `400 Bad Request`
* Error object `code`: `__MISSING_REQUIRED_ACTION_ARGUMENT__`
* Error object `source`: SHOULD be `{ "pointer": "P" }` where P is a pointer to where the unsupplied argument was expected (e.g. `/arguments/title`)

#### Unknown action argument

To be used when an action request body includes an argument field that is not recognized by the server.

* HTTP status: `400 Bad Request`
* Error object `code`: `__UNKNOWN_ACTION_ARGUMENT__`
* Error object `source`: SHOULD be `{ "pointer": "P" }` where P is a pointer to the unknown argument (e.g. `/arguments/fish`)

#### Invalid request document content

To be used when the SASC document in the request body is valid JSON but does not confirm to this specification.

* HTTP status: `400 Bad Request`
* Error object `code`: `__INVALID_REQUEST_DOCUMENT_CONTENT__`
* Error object `source`: SHOULD be `{ "pointer": "P" }` where P is a pointer to the invalid part of the document (e.g. `/data/peanutButter`)

#### Invalid request document format

To be used when the SASC document in the request body is not valid JSON

* HTTP status: `400 Bad Request`
* Error object `code`: `__INVALID_REQUEST_DOCUMENT_FORMAT__`

#### Bad URL pattern

To be used when a URL does not match a known pattern. This MAY also be used when the client does not have permission to do anything at the given pattern.

* HTTP status: `404 Not Found`
* Error object `code`: `__BAD_URL_PATTERN__`

#### Bad method

To be used when a URL references a known pattern, but the server does not implement the given HTTP method for that pattern. 

* HTTP status: `405 Method Not Allowed`
* Error object `code`: `__BAD_METHOD__`

#### Bad Individual Resource URL id

To be used when an Individual Resource URL id does not reference a valid resource. This MAY also be used when the client does not have permission to do anything with the given resource.

* HTTP status: `404 Not Found`
* Error object `code`: `__BAD_INDIVIDUAL_RESOURCE_URL_ID__`

#### Authentication needed

To be used when explicitly telling the client that the server does not permit this action because it does not recognize who the client is.

The client SHOULD respond, if possible, by showing the user a login dialog or equivalent.

* HTTP status: `401 Unauthorized`
* Error object: `code`: `__AUTHENTICATION_NEEDED__`

#### Permission denied

To be used when explicitly telling the client that, although their identity is recognized, they are still not permitted to perform the action.

The client SHOULD NOT attempt to show the user a login dialog, unless it has reason to expect that the user might have *another* login to use which has the necessary permissions.

* HTTP status: `403 Forbidden`
* Error object: `code`: `__PERMISSION_DENIED__`

#### Unknown API version

To be used when the `X-SASC-API-Version` header in the request refers to an API version that the server has no knowledge of, e.g. because it is newer than the server's latest supported API version.

* HTTP status: `400 Bad Request`
* Error object: `code`: `__UNKNOWN_API_VERSION__`

#### Incompatible API version

To be used when the `X-SASC-API-Version` header in the request refers to an old version that, for this request, the server can no longer provide compliant behavior for.

* HTTP status: `400 Bad Request`
* Error object: `code`: `__INCOMPATIBLE_API_VERSION__`

#### Bad Content-Type header

To be used when the `Content-Type` header on a request with a body is not `application/json`, or the `Content-Type` header is present on a request without a body.

* HTTP status: `415 Unsupported Media Type`
* Error object `code`: `__BAD_CONTENT_TYPE_HEADER__`
* Error object `source`: `{ "header": "Content-Type"}`

#### Bad Accept header

To be used when the request `Accept` header does not allow for `application/json`

* HTTP status: `406 Not Acceptable`
* Error object `code`: `__BAD_ACCEPT_HEADER__`
* Error object `source`: `{ "header": "Accept"}`

#### Bad header

To be used when a necessary header is missing or a header has an invalid value, and no other more-specific error condition (e.g. "Unknown API version" or "Bad Accept header") applies.

* HTTP status: `400 Bad Request`
* Error object `code`: `__BAD_HEADER__`
* Error object `source`: `{ "header": "H"}` where H is the invalid header

#### Deprecated client version

To be used when a request is made using a client whose version (as specified in `X-SASC-Client`) has been deprecated.

* HTTP status: `410 Gone`
* Error object `code`: `__DEPRECATED_CLIENT_VERSION__`

#### Internal error

To be used when the server has experienced an unexpected problem that was not due to any issues with the request, but instead because of something going wrong with the server and/or a third party.

* HTTP status: `500 Internal Server Error`
* Error object `code`: SHOULD be an application-specific code categorizing the nature of the problem

## Documentation

Because SASC is not HATEOAS, clients have no way of reflecting on the API programatically. API documentation for client authors SHOULD be provided, including at least:

* The available URL patterns, with:
    * The methods supported
    * Any necessary preconditions for access (e.g. permissions)
* Specifically for GET requests on Collection URLs:
    * Which filters are available, and what JSON types each accepts
    * Which sort arguments are available, and any limits on maximum number of sort arguments accepted
    * The maximum and default `page[limit]`, and the maximum `page[offset]`
* The available resource types, with:
    * The attributes available, with their JSON types
    * Any read-only or write-only attributes
    * The relationships available
    * Validation requirements
    * For new changes or features, the API version which introduced those changes
    * Which related resources are included, and when
    * **Deprecation of any attributes and relationships, and the API version where the deprecation occurred**
* Application-specific error codes and subcodes
* Which API versions are supported by the server, and the differences between them
